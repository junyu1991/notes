# JVM G1

G1回收算法是为多核心，大内存的机器而设计的。只需少量的配置就可满足在实现高吞吐的同时降低暂停时间。G1旨在当前的环境下使应用程序在延迟和吞吐之间实现最佳平衡，当前的环境特点主要包括：
- 堆空间大小通常都是10GB或者更大，堆空间中的50%都是实时数据。
- 随着时间的变化，对象的分配以及晋升的速度会显著变化。
- 堆中有大量的碎片。
- 可预测的暂停时间不超过几百毫秒，避免了gc的长时间暂停。

## 1 基础
G1是一个分代的，增量的，并行的，主要是并发的，具有stop-the-world特性的垃圾回收器，他会在每次stop-the-world的时候监控暂停时间。与其他的垃圾回收器一样，G1也将堆虚拟的划分成了年轻代和老年代。空间的回收也主要集中于年轻代中，因为年轻代中的对象生存周期最短，这样做效率最高，而老年代的空间回收操作则比较少。

G1算法中，为提高吞吐量，一些操作是在stop-the-world的时候进行的。而其他需要花费更多时间的操作如标记堆中所有的对象则是和应用一起平行并发执行的。为了使stop-the-world的时间更短，G1分步并行的执行空间回收操作。G1通过追踪应用之前的行为以及上次gc的信息构建出的模型实现了预测能力。

G1算法主要通过疏散来实现空间回收：在需要回收的区域中找到live对象，将他们复制到新的内存区域，**并在这个过程中对他们进行压缩操作**。在这个操作完成后，这些对象之前所在的区域就可以被用来分配给新的对象。
G1算法不是实时的回收算法，它视图在更长的时间内以高概率满足设定的暂停时间的目标，但并不总是对给定的暂停有绝对的把握。

## 2 G1使用的堆分布

G1将堆划分成了一块一块的更小的空间，如图1所示所示。每个小块都是内存分配以及回收的基本单位。在任意时刻，这些内存块可以是空的（浅灰色），也可以是被分配给特定的世代（年轻代或者老年代）。当收到申请内存的请求，内存管理器会交出空闲的内存块。内存管理器将他们分配给一个指定的世代然后将他们作为可用空间返回给应用程序，应用程序可自己分配这些空间。
![图1](./img/g1heaplayout.png)
图中浅灰色的小格子是可用的空闲空间，蓝色的则是老年代空间，蓝色方块中有"H"的则是老年代空间中占用空间较多的对象所占用的空间，蓝色框中有红色小框的则是年轻代空间，红色方块中有"S"的是年轻代中的survivor空间，其余没有"S"的红色框的则是eden空间。

从分布图可以看出，G1对堆空间的划分与其他GC算法的划分方式都不一样，其他的算法划分中老年代和年轻代都是连续的内存空间，G1的年轻代和老年代不是连续的。

一个应用通常都是讲新对象分配到年轻代中即年轻代的eden空间。当出现需要占用超过最小块空间的对象出现时，则直接将该对象分配到老年代中。

G1 gc暂停时可以回收整个年轻代空间，而且能在任意一个暂停时刻回收其他老年代空间。在暂停期间，G1会将选定的对象复制堆中的其他内存块中，至于复制到哪些块中，则是根据当前被复制的对象来决定：年轻代中的对象要么被复制到survivor空间中要么被复制到老年代空间中，而老年代中的对象则是到老年代中的其他不同区域（压缩操作）。


参考链接：
[G1 basic](https://docs.oracle.com/javase/10/gctuning/garbage-first-garbage-collector.htm#JSGCT-GUID-F1BE86FA-3EDC-4D4F-BDB4-4B044AD83180)