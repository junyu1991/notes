# Redis Transaction(事务)

Redis提供的**multi, exec, discard, watch**命令是基于Redis事务控制的。Redis事务控制提供了两个绝对保障：
- 同一事务中的所有命令都是序列化的且按照顺序被执行的。Redis事务的执行过程中，不会处理另一个客户端请求。这样可以确保将事务中的所有命令作为单个隔离操作执行。
- 同一事务中的命令要么全部执行要么全部不执行，因此Redis事务是原子性操作。

当执行**exec**命令时就会触发Redis执行事务中的所有命令。如果客户端在调用MULTI命令之前在事务上下文中失去与服务器的连接，则Redis不会执行任何操作，如果调用了EXEC命令，则执行所有操作。
当Redis使用 **append-only file**时，Redis会使用单个系统调用```write(2)```将事务写入硬盘。如果Redis崩溃或者被管理员
强行停止，可能会出现一个事务只有一部分操作被写入到文件中，重启Redis时，Redis会检测到这种情况并重启失败，使用**redis-check-aof**工具可修改这个问题，
这样操作会删除不完善的事务。

## 事务使用示例
使用**multi**命令可进入Redis事务，执行此命令后，Redis Server会返回**OK**，接到该结果后就可提交需要执行多条命令，
与直接执行命令不同的是，此时Redis Server会将接收到的命令填充到一个队列中，直到接收到**exec**命令才会将队列中的所有
命令执行操作。执行**discard**命令会清空命令队列中缓存的所有命令，并退出当前事务。
``` shell
> MULTI
OK
> INCR foo
QUEUED
> INCR bar
QUEUED
> EXEC
1) (integer) 1
2) (integer) 1
```
Redis事务是以**multi**命令开始的，以**exec**命令为结束，可将**exec**命令视为sql中commit语句。

> 当执行一个事务时，在未提交**exec**命令之前，其他客户端对事务中操作的key的操作是有效的，如以上示例中，
在exec之前，另一个客户端执行```incr foo```命令会增加foo的值，而以上事务执行结果也会更改为：foo=2,bar=1。

执行完事务（执行**exec**命令）之后Redis Server会返回一组执行结果，结果按照命令提交顺序排序。在事务中时，提交
命令会返回**QUEUED**。

## 事务中可能会出现的错误

在事务执行中可能会出现以下两种错误：
- 在调用**exec**命令前出错，即在将提交的命令插入命令队列中时出错。出错的原因可能包括：命令名错误，
命令参数错误，或Redis Server内存不足错误。
- 在调用**exec**命令后出错，即在执行事务中的命令时出错。出错原因可能是：对key执行了错误的操作，如对list进行了set操作。
对于第一种错误，客户端可通过提交命令后的返回结果检测出：提交命令成功会返回**QUEUED**，否则则是提交命令失败。
当出现提交命令失败的结果时，客户端可调用**discard**退出当前事务。从Redis 2.6.5开始，Redis Server会记录事务中的错误命令，
并不会执行有错误的事务，同时在EXEC期间返回错误并自动丢弃该事务；在2.6.5之前的Redis中，Redis Server只会在命令集全正确的情况下执行，预防客户端不处理异常就执行exec操作。
这种新行为使将事务与流水线混合起来变得更加简单，因此可以一次发送整个事务，稍后再读取所有返回结果。
对于第二种错误，Redis Server会执行事务中其他所有正确命令。即即使在事务中某些命令失败，也不会影响其他正确的命令的执行。

## Redis不支持回滚操作
与关系型数据库不同，Redis不支持回滚操作。

## WATCH命令

**WATCH**命令为Redis事务提供了CAS(check-and-set)保障。当设置了WATCH的键在执行**EXEC**之前被修改了，当前整个事务
都会终止，**EXEC**命令会返回空以提示客户端事务执行失败。
使用示例：
``` shell
WATCH zset
element = ZRANGE zset 0 0
MULTI
ZREM zset element
EXEC
```
**WATCH**主要用于保证在事务仅在watch键未被修改的情况才被执行。如果是事务内部的同一客户端更改则不会终止事务执行。
如果watch键在watch之后过期了，事务依然会被执行。

**WATCH**可被多次调用，也可一次WATCH多个key，当**EXEC**被调用时，所有的WATCH都会被取消，不管EXEC调用成功与否。
同样，当客户端断开连接时，该客户端设置的WATCH也会被取消。也可用UNWATCH命令取消WATCH。

> 不同的客户端对于同一key的WATCH是不会相互影响的，即A客户端watch了keya，B客户端未watch keya，B客户端的事务执行不会受到
A客户端watch的影响。